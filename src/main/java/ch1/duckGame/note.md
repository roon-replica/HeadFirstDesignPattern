# 소프트웨어 개발 불변의 진리
  - **변화**가 블변의 진리라고 함
  - 디자인을 잘한 애플리케이션이라도 시간이 지남에따라 변화하고 성장?해야 함

  - 변경이 필요했던 경험들
    - 언어 enum을 설계했을 때 일본어를 ja(jp였나)로 했는데 브라우저에서 반대였어서 변경했던 경험
    - 다른 프록시를 사용하도록 변경
    - 도메인을 리다이렉트
    - model and view를 반환하는 API를 json을 반환하도록 변경
    - circuit breaker, retry를 적용하도록 변경
    - 화면 UI가 알아보기 힘들어서 UI를 변경. 이에 따라 렌더링, 이벤트, 서버에서 데이터를 넘겨주는 코드도 많이 변경함


# 오리 문제
  - 오리 문제에서는 상속, 인터페이스 둘 다 변경에 잘 대처할 수 없었음 (나름 괜찮은거 같은데 문제라고 함..)
  - **변경되는 부분을 따로 뽑아서 캡슐화**하면 해결된다고 함..
    
    그럼 나중에 변경되지 않는 부분에는 영향을 주지 않고, 변경되는 부분만 수정할 수 있어서.
    
    **근데 변경되는 부분이 특정 가능? 변경이 안 되는 부분이 있나? 앞으로 변경될지 어떻게 앎? => 예측..!** 

# 디자인 패턴 사용, 학습 이유
- 패턴으로 소통하면 더 효율적으로 의사소통 가능
- 서로가 디자인패턴이라는 공용어가 생겨서 의사소통 수월해짐
- 간단한 단어로 많은 얘기 가능
- 구현 세부사항보다 디자인에 더 집중 가능
- 라이브러리, 프레임워크가 쉬운 기능 개발에 도움을 주지만 유연한 시스템 구조는 디자인 패턴으로 챙겨야 함!

# 객체지향 기초, 원칙, 패턴
- 기초: 추상화, 캡슐화, 다형성, 상속
- 원칙
  - 바뀌는 부분을 캡슐화
  - 상속보다는 composition(위임)
  - Liskov substitution principle
- 패턴
  - ex) 전략 패턴 (알고리즘을 캡슐화해서 정의해두고 쓰는 패턴. 클라이언트와 알고리즘을 분리하는 장점)

# 깨달음
- 디자인 패턴 적용하기 전에 `이렇게 분리하면 재사용이 가능해지냐?`라고 자문해보기
- 레퍼런스를(타입을) 다형적으로 설정한다는 말의 뜻
  - List랑 ArrayList 관계 말하는거임
- 확실히 변하는 부분, 변하지 않는 부분 나누니까 변경에 대응하긴 좋을듯
- **나중에 어떻게 바뀔지 예상할 수 있으면 관리하기 쉬운 객체지향 시스템을 만들 수 있다!**